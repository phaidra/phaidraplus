<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>components/data-manager.js - Phaidra+</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="Phaidra+" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/basics.html">basics</a></li>
                                <li><a href="../classes/collectionManager.html">collectionManager</a></li>
                                <li><a href="../classes/dataManager.html">dataManager</a></li>
                                <li><a href="../classes/downloadManager.html">downloadManager</a></li>
                                <li><a href="../classes/geoView.html">geoView</a></li>
                                <li><a href="../classes/lightroomCollections.html">lightroomCollections</a></li>
                                <li><a href="../classes/phaidraObject.html">phaidraObject</a></li>
                                <li><a href="../classes/phaidraQue.html">phaidraQue</a></li>
                                <li><a href="../classes/pptCreator.html">pptCreator</a></li>
                                <li><a href="../classes/resourceManager.html">resourceManager</a></li>
                                <li><a href="../classes/search.html">search</a></li>
                                <li><a href="../classes/searchFilter.html">searchFilter</a></li>
                                <li><a href="../classes/searchRequestManager.html">searchRequestManager</a></li>
                                <li><a href="../classes/singleView.html">singleView</a></li>
                                <li><a href="../classes/standalone.html">standalone</a></li>
                                <li><a href="../classes/timeline.html">timeline</a></li>
                                <li><a href="../classes/timelineObject.html">timelineObject</a></li>
                                <li><a href="../classes/uncategorizesObjects.html">uncategorizesObjects</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/basics.html">basics</a></li>
                                <li><a href="../modules/helpers.html">helpers</a></li>
                                <li><a href="../modules/main.html">main</a></li>
                                <li><a href="../modules/main
                
                ## TODO
                
                - Update View when data is changed.html">main
                
                ## TODO
                
                - Update View when data is changed</a></li>
                                <li><a href="../modules/resources.html">resources</a></li>
                                <li><a href="../modules/search.html">search</a></li>
                                <li><a href="../modules/viewControllers.html">viewControllers</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: components/data-manager.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
 * @module resources
 */
define([&#x27;jquery&#x27;, &#x27;components/_P_&#x27;, &#x27;config/general&#x27;,&#x27;spin&#x27;, &#x27;jquery.cookie&#x27;], function ($, _P_,CONF, S) {
    
    /**
     * The data manager gets the raw data from a search request, transform it into usable and displayable objects
     * and provides useful methods to sort, restrict data or manipulate it.

     @class dataManager
     @constructor
     */
    /**
     Event called when something changes in the data manager

     @event dataManager:change
     @param {Object} self the data manager instance
     */
    /**
     Event called when something changes in the data manager

     @event dataManager:changeDisplayed
     @param {Object} self the data manager instance
     */
    /**
     Event called when a collection is added, changed or removed

     @event dataManager:collections
     @param {Array} collections the available collections
     */
    /**
     Event called when the preferred set of objects to be displayed changes

     @event dataManager:displayModeChanged
     @param {String} mode the new display mode
     */
    /**
     Event called when the keywords of an object are changed

     @event dataManager:keywords
     @param {Array} keywords the available keywords
     */
    /**
     Event called when an object is marked or unmarked

     @event dataManager:marked
     @param {Array} marked the currently marked objects
     */
    /**
     Event called when objects are added, changed or removed

     @event dataManager:objects
     @param {Array} objects the currently available objects
     */
    var dataManager = function()
    {
        /**
         * Property containing all objects loaded over multiple pages 
         * 
         * @property allLoadedObjects
         * @type {Array}
         */
        this.allLoadedObjects = [];
        /**
         * Property containing all objects of the current page
         * 
         * @property objects
         * @type {Array}
         */
        this.objects = [];
        /**
         * Array containing all unique keywords of the objects
         * 
         * @property keywords
         * @type {Array}
         */
        this.keywords = [];
        /**
         * Object referencing elements from the objects array by its keywords.
         * References start with &#x27;t&#x27;, i.e. &#x27;tMyTerm&#x27;: {object}
         * 
         * @property keywordhash
         * @type {Object}
         */
        this.keywordhash = {};
        /**
         * Object containing a keyword count by term.
         * References start with &#x27;t&#x27;, i.e. &#x27;tMyTerm&#x27;: {object}
         * 
         * @property keywordnums
         * @type {Object}
         */
        this.keywordnums = {};
        /**
         * Array containing the collections found in the {{#crossLink &quot;dataManager:objects&quot;}}objects Array{{/crossLink}}.
         * References start with &#x27;t&#x27;, i.e. &#x27;tMyTerm&#x27;: {object}
         * 
         * @property collections
         * @type {Object}
         */
        this.collections = [];
        /**
         * Object containing the maximum geographic boundary of the objects found in the {{#crossLink &quot;dataManager:objects&quot;}}objects Array{{/crossLink}}.
         * Object according to { southWest: { south: [Integer], west: [Integer] }, northEast: { north: [Integer], east: [Integer] }}
         * 
         * @property bounds
         * @type {Object}
         */
        this.bounds = {};
        /**
         * Array containing all objects stared/marked by the user.
         * 
         * @property objectsmarked
         * @type {Object}
         */
        this.objectsmarked = [];
        /**
         * Flag indicating whether the stack of all loaded objects shall be wipped or not.
         * 
         * @property saveLoadedObjects
         * @type {Boolean}
         */
        this.saveLoadedObjects = false;
        /**
         * Backreference
         * 
         * @property self
         * @private
         * @type {Object}
         */
        var self = this;
        /**
         * Flag indicating which displaymode is currently active (null|all|marked|collection|keyword)
         * 
         * @property displayMode
         * @private
         * @type {Enum}
         */
        var displayMode = &#x27;all&#x27;; // null, all, marked, collection, keyword
        /**
         * The UID of the currently selected collection if dataManager:displayMode is collection.
         * 
         * @property selectedCollection
         * @default &#x27;all&#x27;
         * @private
         * @type {String}
         */
        var selectedCollection = null;
        /**
         * The currently selected keyword if dataManager:displayMode is keyword.
         * 
         * @property selectedKeyword
         * @private
         * @type {String}
         */
        var selectedKeyword = null;
        /**
         * Index of the currently selected Object in the dataManager:currentObjects Array.
         * 
         * @property selectedObject
         * @private
         * @type {Integer}
         */
        var selectedObject = 0;
        /**
         * Array containing the currently selected objects resulting from changes in the dataManager:displayMode.
         * 
         * @property currentObjects
         * @private
         * @type {Array}
         */
        var currentObjects = [];        
        /**
         * Method to clear all marked objects in the result set.
         * Sets display mode to &#x27;all&#x27;. Triggers  {{#crossLink &quot;dataManager/marked:event&quot;}}{{/crossLink}},
         * {{#crossLink &quot;dataManager/changeDisplayed:event&quot;}}{{/crossLink}} and {{#crossLink &quot;dataManager/change:event&quot;}}{{/crossLink}} if appropriate.
         *
         * @method clearMarked
         * @chainable
         * return {Object} self
         */
        this.clearMarked = function()
        {
            var wasMarkedMode = false;

            self.markObjects(false);

            if (displayMode == &#x27;marked&#x27;) {
                wasMarkedMode = true;
                setDisplayMode(&#x27;all&#x27;);
            }

            $(self).trigger(&#x27;marked&#x27;, []);
            if (wasMarkedMode) {
                $(self).trigger(&#x27;changeDisplayed&#x27;, [self]);    
            }
            $(self).trigger(&#x27;change&#x27;, [self]);
            return self;
        };
        /**
         * Helper method to convert an angle in degrees, minutes and seconds to full degrees
         *
         * @method convertDMSToDD
         * @param {Float} degrees
         * @param {Float} minutes
         * @param {Float} seconds
         * @param {Enum} direction (S|W|N|E)
         * @return {Float}
         */
        this.convertDMSToDD = function(degrees, minutes, seconds, direction)
        {
        var dd = parseInt(degrees) + minutes/60 + seconds/(60*60);
        if (direction == &quot;S&quot; || direction == &quot;W&quot;) {
            dd = dd * -1;
        } // Don&#x27;t do anything for N or E
        return dd;
        }
        /**
         * Method reseting all important attributes.
         *
         * @method clear
         * @chainable
         * return {Object} self
         */
        this.clear = function()
        {
            self.keywords = [];
            self.keywordhash = {};
            self.keywordnums = {};
            self.objects = [];
            self.objectsmarked = [];
            selectedObject = 0;
            currentObjects = [];

            if (!self.saveLoadedObjects) {
                self.allLoadedObjects = [];
                selectedCollection = 0;
                setDisplayMode(&#x27;all&#x27;, true);
            }
            self.saveLoadedObjects = false;

            self.bounds = { southWest: { south: 40, west:-4 }, northEast: { north:52, east:30 }}; // (lat) north positive, south negative, (lon) east: positive, west: negative

            self.updateKeywords();
            return self;
        };
        /**
         * Method to register the {{#crossLink &quot;dataManager&quot;}}{{/crossLink}} with the {{#crossLink &quot;resourceManager&quot;}}{{/crossLink}}
         *
         * @method create
         * @chainable
         * return {Object} self
         */
        this.create = function()
        {    
            resourceMan.setResource(&#x27;gsaData&#x27;, self);
            self.clear();
            
            resourceMan.setConfig(&#x27;searchFinished&#x27;, &#x27;parseData&#x27;, {
                &#x27;deps&#x27;: [&#x27;components/data-manager&#x27;],
                &#x27;open&#x27;: { &#x27;scope&#x27;: self, &#x27;func&#x27;: self.manageSearchData },
                &#x27;close&#x27;: { &#x27;scope&#x27;: self, &#x27;func&#x27;: self.done },
            });

            return self;
        };

        this.done = function()
        {
        };

        this.dontClearAll = function()
        {
            self.saveLoadedObjects = true;
        };

        /**
         * Method returns an array of all collection the object belongs to.
         *
         * @method objectFindCollections
         * @param {Object} object
         * @return {Array} An Array of UIDs the object is already member of
         */
        this.objectFindCollections = function(obj)
        {
            var cols = [];
            for (var i = self.collections.length - 1; i &gt;= 0; i--) {
                var collection = self.collections[i];
                for (var k = collection.objects.length - 1; k &gt;= 0; k--) {
                    var o = collection.objects[k];
                    if(o.data.pid == obj.data.pid) {
                        cols.push(collection.uid);
                    }
                };
            };
            return cols;
        }
        /**
         * Method to sort the collections depending on the sort array (uids).
         *
         * @method sortCollections
         * @param {Array} sort An array of uids
         * @chainable
         * return {Object} self
         */
        this.sortCollections = function(sort)
        {
            var newSort = [];

            for (var i = 0; i &lt; sort.length; i++) {
                var uid = sort[i];
                var index = self.getCollectionIndex(uid);
                newSort.push(self.collections[index]);
            };
            self.collections = newSort;
            return self;
        }
        /**
         * Method to retrieve a collection&#x27;s index in the {{#crossLink &quot;dataMan/collections:attribute&quot;}}{{/crossLink}} array based on its UID.
         *
         * @method getCollectionIndex
         * @return {Integer} the index in the array or -1 if not found
         */
        this.getCollectionIndex = function(uid)
        {
            for (var i = self.collections.length - 1; i &gt;= 0; i--) {
                if(self.collections[i].uid == uid) {
                    return i;
                }
            }
            return -1;
        };
        /**
         * Method to clear and add new objects to the allLoadedObjects array
         *
         * @method copyToAllLoadedObjects
         * @param {Array} objects The objects to store
         * @param {Boolean} clear Flag whether to clear the objects or not.
         * @chainable
         * return {Object} self
         */
        this.copyToAllLoadedObjects = function(objs, clear)
        {
            if (clear) {
                this.allLoadedObjects = [];
            }

            for(var i=0; i&lt;objs.length; i++) {
                this.allLoadedObjects[objs[i].data.pid] = objs[i];
            }

            return this;
        };
        /**
         * Method to create/register a collection with certain data.
         *
         *    data = { objects: [], d.uid: new String(), title: new String(), updated: new Date() }
         *
         * The data is converted and stored in the {{#crossLink &quot;dataMan/collections:attribute&quot;}}{{/crossLink}} array.
         *
         * @method createCollection
         * @param {Object} data The data to create/store a collection from
         * @chainable
         * return {Object} self
         */
        this.createCollection = function(d)
        {
            var n = new Array();
            for(var i=0;i&lt;d.objects.length;i++) {
                var p = new _P_(d.objects[i].data);
                n.push(p);
            }
            var uid;
            
            if(d.uid) {
                uid = d.uid;
            } else {
                uid = &quot;c&quot;+new Date().getTime()
            }

            self.collections.unshift({title:d.title,&quot;objects&quot;:n,uid:uid,updated:d.updated});
            return self;
        }
        /**
         * Method to get a collection depending on the collection&#x27;s title.
         *
         * @method getCollection
         * @param {String} title
         * @return {Array} The collection or null if not found
         */
        this.getCollection = function(title)
        {
            for(var i in self.collections) {
                if (self.collections[i].title == title) {
                    return self.collections[i];
                }
            }
            for(var i in self.collections) {
                if (self.collections[i].uid == title) {
                    return self.collections[i];
                }
            }
            return null;
        };
        /**
         * Get a specific object from the result set by its PID.
         *
         * @method getObject
         * @param {String} pid
         * @return {String} The object or null if not found.
         */
        this.getObject = function(pid, searchInAll)
        {
            searchInAll = (typeof searchInAll == &#x27;undefined&#x27; || searchInAll == null) ? false : searchInAll;
            for(var i in self.objects) {
                if (self.objects[i].data.pid == pid) {
                    return self.objects[i];
                }
            }

            if (searchInAll &amp;&amp; typeof self.allLoadedObjects[pid] == &#x27;object&#x27;) {
                return self.allLoadedObjects[pid];
            }

            return null;
        };
        /**
         * Getter Function for {{#crossLink &quot;dataManager/currentObjects:attribute&quot;}}{{/crossLink}}.
         *
         * @method currentObjects
         * @return {Array}
         */
        this.getObjects = function()
        {
            return currentObjects;
        };
        /**
         * Method updating the the {{#crossLink &quot;dataManager/keywords:attribute&quot;}}{{/crossLink}},
         * {{#crossLink &quot;dataManager/keywordshash:attribute&quot;}}{{/crossLink}} and {{#crossLink &quot;dataManager/keywordnums:attribute&quot;}}{{/crossLink}} arrays.
         * 
         * @method updateKeywords
         * @chainable
         * return {Object} self
         */
        this.updateKeywords = function()
        {
            self.keywords = [];
            self.keywordhash = {};
            self.keywordnums = {};
            
            var objs = self.getObjects();
            for(var i in objs) {
                var o = objs[i];
                self.getKeywords(o.data);
            }
            return self;
        }
        /**
         * Method extracting the keyword of an object and adding it to the {{#crossLink &quot;dataManager/keywords:attribute&quot;}}{{/crossLink}},
         * {{#crossLink &quot;dataManager/keywordshash:attribute&quot;}}{{/crossLink}} and {{#crossLink &quot;dataManager/keywordnums:attribute&quot;}}{{/crossLink}} arrays.
         * 
         * @method getKeywords
         * @param {Object} object The object to check
         * @chainable
         * return {Object} self
         */
        this.getKeywords = function(obj)
        {
            if(!obj.subject) return self;

            for (var i = obj.subject.length - 1; i &gt;= 0; i--) {
                var s = obj.subject[i];
                if(!s || !s.taxon) continue;
                var path = s.taxon;
                if(!pathÂ || !path.length) continue;

                if (typeof path == &quot;string&quot;) {
                    path = [path];
                }
                
                var term = path[path.length-1];
                if(!term || $.trim(term).length &lt; 3) continue;

                if(self.keywords.indexOf(term) == -1) {
                    self.keywords.push(term);
                    self.keywordhash[&quot;t&quot;+term] = s;
                    self.keywordnums[&quot;t&quot;+term] = 1;
                } else {
                    self.keywordnums[&quot;t&quot;+term]++;
                }
            }
            return self;
        }
        /**
         * Getter method for the {{#crossLink &quot;dataManager/objectsmarked:attribute&quot;}}{{/crossLink}} array.
         *
         * @method getMarked
         * @return {Array}
         */
        this.getMarked = function()
        {
            return self.objectsmarked;
        };
        /**
         * Method to retrieve all objects in the result set for a certain keyword (regex).
         *
         * @method getObjectsForKeyword
         * @param {String} term the keyword term
         * @return {Array} An array of matching objects from the result set.
         */
        this.getObjectsForKeyword = function(term)
        {
            var objs = [];
            var re = new RegExp(&quot;\\|\\|&quot;+term+&quot;$&quot;, &quot;i&quot;); // double escaping (for string and for regex)!!!
            var cobjs = self.objects;
            for(var i in cobjs) {
                var o = cobjs[i];
                if (typeof o.data.subject == &#x27;undefined&#x27; || o.data.subject == null || o.data.subject.length &lt;= 0) { continue; }
                
                for(var s in o.data.subject) {
                    var tax = o.data.subject[s].taxon;

                    if (tax &amp;&amp; tax[tax.length-1] == term) {
                        objs.push(o);
                    }
                }
            }
            return objs;
        };
        /**
         * Getter function for the currently selected collection (uid).
         *
         * @method getSelectedObject
         * @return {Object}
         */
        this.getSelectedCollection = function()
        {
            return selectedCollection;
        };
        /**
         * Extended Getter function to retrieve the currently selected object.
         *
         * @method getSelectedObject
         * @return {Object}
         */
        this.getSelectedObject = function()
        {
            return currentObjects[selectedObject];
        };
        /**
         * Method called after data has been loaded from the GSA.
         * Checks the results, repairs the data and creates _P_ objects from the data.
         * After successful conversation, sets itself as the resource &#x27;gsaData&#x27; with the resource manager and triggers all events of the class.
         * 
         * @method manageData
         * @param {Object} Data The result data to convert into a result set.
         * @param {Boolean} [alert=true] Shall there be an alert when no results were returned?
         * @chainable
         * return {Object} self
         */
        this.manageData = this.manageSearchData = function(d, alert)
        {            
            // for (var i = 0; i &lt; self.objects.length; i++) {
            //     self.objects[i].destroy();
            // };
            alert = (typeof alert == &#x27;undefined&#x27;) ? true : alert;
            self.clear();

            if (typeof d == &#x27;undefined&#x27; || d.length == 0) {
                if (alert) {
                    //window.alert(&#x27;Sorry, this search resulted in ZERO results. Please alter your search parameters...&#x27;);
                    $(&quot;#mainsection&quot;).append(&quot;&lt;h1 class=&#x27;alert&#x27;&gt;Sorry, this search resulted in ZERO results. Please alter your search parameters...&lt;/h1&gt;&quot;)
                    setTimeout(function(){
                        $(&quot;#mainsection h1.alert&quot;).fadeOut(function(){
                            $(&quot;#mainsection h1.alert&quot;).remove();
                        });
                    },2000)
                }
                //return;
            }
            

            for(var i in d) {
                var obj = d[i];
                
                if(!obj.MT) {
                    log(&quot;error no MT&quot;);
                    continue;
                }
                
                obj = obj.MT;
                
                if(!obj.preview &amp;&amp; !obj.file) {
                    log(&quot;error no file&quot;)
                    continue;
                }
                
                obj = self.repairData(obj);
                
                if(!obj) {
                    continue;
                }
                
                var p = new _P_(obj);
                p._marked = false;

                if (typeof self.allLoadedObjects[p.data.pid] == &#x27;object&#x27;) {
                    p._marked = self.allLoadedObjects[p.data.pid]._marked;
                } else {
                    self.allLoadedObjects[p.data.pid] = p;
                }

                self.objects.push(p);
            }

            currentObjects = self.objects;
            self.updateKeywords();
            self.updateMarked();

            resourceMan.setResource(&#x27;gsaData&#x27;, self);

            $(self).trigger(&#x27;objects&#x27;, [self.objects]);
            $(self).trigger(&#x27;collections&#x27;, [self.collections]);
            $(self).trigger(&#x27;marked&#x27;, [self.getMarked()]);
            $(self).trigger(&#x27;keywords&#x27;, [self.keywords]);
            $(self).trigger(&#x27;displayModeChanged&#x27;, [displayMode]);
            $(self).trigger(&#x27;changeDisplayed&#x27;, [self]);
            $(self).trigger(&#x27;change&#x27;, [self]);

            $(window).trigger(&quot;dataManaged&quot;, [self]);
            return self;
        };
        /**
         * Method to mark all currently displayed objects.
         * Triggers  {{#crossLink &quot;dataManager/marked:event&quot;}}{{/crossLink}},
         * {{#crossLink &quot;dataManager/changeDisplayed:event&quot;}}{{/crossLink}} and {{#crossLink &quot;dataManager/change:event&quot;}}{{/crossLink}} if appropriate.
         *
         * @method markObject
         * @chainable
         * return {Object} self
         */
        this.markAll = function()
        {
            this.markObjects(true);
            self.updateMarked();
            currentObjects = self.getMarked();

            if(!$.cookie(&quot;joyride-mark&quot;)) {
                var helpItems=[&quot;marker-actions&quot;];
                $(window).trigger(&quot;showhelp&quot;,[{items:helpItems}]);
                $.cookie(&quot;joyride-mark&quot;,true);
            }

            $(self).trigger(&#x27;marked&#x27;, [self.getMarked()]);
            if (displayMode == &#x27;marked&#x27;) {
                $(self).trigger(&#x27;changeDisplayed&#x27;, [self]);    
            }
            $(self).trigger(&#x27;change&#x27;, [self]);
            return self;
        };
        /**
         * Method to mark a specific object identified by its pid.
         * Triggers  {{#crossLink &quot;dataManager/marked:event&quot;}}{{/crossLink}},
         * {{#crossLink &quot;dataManager/changeDisplayed:event&quot;}}{{/crossLink}} and {{#crossLink &quot;dataManager/change:event&quot;}}{{/crossLink}} if appropriate.
         *
         * @method markObject
         * @param {String} PID The pid of the object to mark
         * @param {Boolean} [unmark=false] Shall the object be unmarked or marked?
         * @return {String} An encoded String of the search terms for the META Tags
         */
        this.markObject = function(pid, unmark)
        {
            if (typeof unmark == &#x27;undefined&#x27; || unmark == null) {
                unmark = false;
            }

            var obj = self.getObject(pid);
            var modeChanged = false;
            if (obj != null) {
                obj._marked = !unmark;
                self.allLoadedObjects[obj.data.pid]._marked = obj._marked;
            }

            self.updateMarked();

            if (displayMode == &#x27;marked&#x27;) {
                if (self.getMarked().length == 0) {
                    setDisplayMode(&#x27;all&#x27;);
                    modeChanged = true;
                } else {
                    currentObjects = self.getMarked();
                }
            }

            $(self).trigger(&#x27;marked&#x27;, [self.getMarked()]);
            if (displayMode == &#x27;marked&#x27; || modeChanged) {
                $(self).trigger(&#x27;changeDisplayed&#x27;, [self]);    
            }
            $(self).trigger(&#x27;change&#x27;, [self]);
            return self;
        };
        /**
         * Method extending the raw objects with the _marked flag and sets it value according to &#x27;how&#x27;.
         *
         * @method markObjects
         * @param {Boolean} how the value the flag shall be set to.
         * @chainable
         * return {Object} self
         */
        this.markObjects = function(how) {
            for(var i in self.objects) {
                self.objects[i]._marked = how;
            }

            for(var i in self.allLoadedObjects) {
                self.allLoadedObjects[i]._marked = how;
            }

            if (how) {
                self.objectsmarked = self.allLoadedObjects;
            } else {
                self.objectsmarked = [];
            }

            return self;
        };
        /**
         * Method checking whether an object is marked or not. Object is referenced by its PID.
         * 
         * @method isMarked
         * @param {String} PID
         * @return {Boolean} returns the current marking state of the object or null if the object is not found.
         */
        this.isMarked = function(pid)
        {
            var obj = this.getObject(pid, true);
            if (obj == null) {
                return null;
            }

            return self.isObjMarked(obj);
        };
        /**
         * Method checking whether an object is marked or not
         * 
         * @method isObjMarked
         * @param {Object} Object
         * @return {Boolean}
         */
        this.isObjMarked = function(obj)
        {
            return obj._marked;
        };
        /**
         * Method removing a collection from the collection array
         *
         * @method removeCollection
         * @chainable
         * @param {Number|String} uid Uid of the colleciton
         * @param {Boolean} silent Flag whether to trigger events on the dataManager (objects, collections, changeDisplayed, change)
         */
        this.removeCollection = function (uid, silent)
        {
            silent = (typeof silent == &#x27;undefined&#x27;) ? false : true;

            if (self.getSelectedCollection() == uid) {
                selectedCollection = 0;
                setDisplayMode(&#x27;all&#x27;, silent);
            }

            var index = self.getCollectionIndex(uid);
            
            if (index == -1) {
                return self;
            }

            self.collections.splice(index, 1);

            if (silent) {
                return self;
            }

            $(self).trigger(&#x27;objects&#x27;, [self.objects]);
            $(self).trigger(&#x27;collections&#x27;, [self.collections]);
            $(self).trigger(&#x27;changeDisplayed&#x27;, [self]);
            $(self).trigger(&#x27;change&#x27;, [self]);
            return self;
        };
        /**
         * Method performing various data transformations on a result object.
         *
         * @method repairData
         * @param {Object} object The raw object to repair.
         * @return {Object} The repaired object.
         */
        this.repairData = function(obj)
        {
            if (!obj.title) {
                if (obj.title_languages) {
                    obj.title = obj[&quot;title_&quot;+obj.title_languages];
                } else {
                    obj.title = &quot;Kein Titel&quot;;
                }
            }

            obj.description = null;
            if (!obj.description) {
                if (obj.description_languages) {
                    if (obj.description_languages) {
                        obj.description = obj[&quot;description_&quot;+obj.description_languages];
                    } else {
                        obj.description = &quot;Keine Beschreibung vorhanden&quot;;
                    }
                }
            }

            if (obj.keywords &amp;&amp; typeof obj.keywords == &quot;string&quot;) {
                 var keys = obj.keywords.split(&quot;,&quot;).join(&quot;;&quot;).split(&quot;;&quot;);
                 //
                 if (!obj.subject) {
                     obj.subject = [];
                 }
                 
                 if (!(obj.subject instanceof Array)) {
                     obj.subject = [obj.subject];
                 }
                 
                 for (var i = 0; i&lt;keys.length; i++) {
                     var key = $.trim(keys[i]);
                     
                     if(key) {
                         obj.subject.push({source:&quot;Freie Beschlagwortung&quot;,taxon:[key]})
                     }
                 };                 
            };
            
            if (obj.roles) {
                if(obj.roles.entity) {
                    obj.roles = [obj.roles];
                }
            }

            obj.isImage = false;
            obj.isDocument = false;

            if(obj.type == &quot;Image&quot;) {
                obj.isImage = true;
                obj.preview = &quot;preview/&quot;+obj.pid+&quot;/ImageManipulator/boxImage/480/jpg&quot;;
            } else {
                obj.isDocument = true;
                if (obj.preview) {
                    obj.preview = &quot;preview/&quot;+obj.pid+&quot;/Document/preview/480&quot;;
                    obj.image = {&#x27;width&#x27;:384,&#x27;height&#x27;:480};
                } else if(obj.file) {
                    obj.preview = &quot;preview/&quot;+obj.pid+&quot;/Document/preview/480&quot;;
                    obj.image = {&#x27;width&#x27;:384,&#x27;height&#x27;:480};
                } else {
                    return null;
                }
            }

            var instanceURL = obj.installationID.toLowerCase() == &quot;phaidratemp&quot; ? &quot;phaidra-temp&quot; : &quot;phaidra&quot;;
            var preview = obj.preview;

            obj.dbUrl = &#x27;https://&#x27;+instanceURL+&quot;.univie.ac.at/&quot;+obj.pid;
            obj.instance = instanceURL.replace(&quot;-t&quot;,&quot;T&quot;).replace(&quot;ph&quot;,&quot;Ph&quot;);
            obj.preview = &#x27;https://&#x27;+instanceURL+&quot;.univie.ac.at/&quot;+obj.preview;
            obj.preview_large = obj.preview.replace(/\/\d{3}/,&quot;/1600&quot;);
            obj.thumbnail = obj.preview.replace(/\/\d{3}/,&quot;/120&quot;);
            
            obj.download_original = instanceURL+&quot;/download/&quot;+&quot;/get/&quot;+obj.pid+&quot;/bdef:Content/download&quot;;
            obj.download = instanceURL+&quot;/download/&quot;+&quot;/&quot;+preview;
            obj.download_medium = instanceURL+&quot;/download/&quot;+&quot;/&quot;+preview.replace(/\/\d{3}/,&quot;/480&quot;);
            obj.download_small = obj.download_medium.replace(&quot;/960&quot;,&quot;/480&quot;);

            
            if (obj.latlon) {
                var p = obj.latlon.lat;
                if (typeof p[&#x27;split&#x27;] != &#x27;undefined&#x27;) {
                    p = p.split(/[^\d\w]+/);
                    obj.latlon.lat = self.convertDMSToDD(p[0], p[1], p[2], p[3]);
                }
                p = obj.latlon.lon;
                if (typeof p[&#x27;split&#x27;] != &#x27;undefined&#x27;) {
                    p = p.split(/[^\d\w]+/);
                    obj.latlon.lon = self.convertDMSToDD(p[0], p[1], p[2], p[3]);
                }
            }
            
            if (typeof obj.obj_date != &#x27;undefined&#x27; || typeof obj.DATE != &#x27;undefined&#x27;) {
                var date = null;
                try {
                    date = new Date(obj.obj_date || obj.DATE);
                    date.getYear();
                } catch (e) {
                    log(&quot;invalid date&quot;);
                    log(e)
                }
                obj.obj_date = date;
            }

            if (typeof obj.provenience != &#x27;undefined&#x27; &amp;&amp; typeof obj.provenience.contribute != &#x27;undefined&#x27;) {
                var date = null;
                try {
                    var prov = obj.provenience.contribute;
                    if(typeof prov == &quot;object&quot; &amp;&amp; typeof prov[0] == &quot;object&quot;) {
                        prov = prov[0];
                    }
                    var from = new Date(prov.date_from);
                    var to = prov.date_to;
                    if(to) {
                        to = new Date(to);
                        to = to.getTime();
                        from = from.getTime();
                        date = from+(to-from)/2
                    }
                    date = new Date(date);
                    date.getYear();
                } catch (e) {
                    log(&quot;invalid date or other error with provenience date&quot;);
                    log(e)
                }
                obj.obj_date = date;
            }
            if(obj.obj_date) {
                try {
                    var year = obj.obj_date.getYear();
                    if (year == 1970) {
                        
                    }
                } catch (e) {

                }
            }
            return obj;
        }

        this.randomDate = function(from,to){
            if (!from) {
                from = new Date(1900, 0, 1).getTime();
            } else {
                from = from.getTime();
            }
            if (!to) {
                to = new Date(2100, 0, 1).getTime();
            } else {
                to = to.getTime();
            }
            return new Date(from + Math.round(Math.random() * (to - from)));
        }
        /*
         * Method sets display mode to &#x27;marked&#x27; and restricts object to objects having the selected keyword.
         * Triggers {{#crossLink &quot;dataManager/changeDisplayed:event&quot;}}{{/crossLink}} and {{#crossLink &quot;dataManager/change:event&quot;}}{{/crossLink}}.
         * 
         * @method restrictToKeyword
         * @param {String} Keyword The keyword to use for restriction of the current result set.
         * @chainable
         * return {Object} self
         */
        this.restrictToKeyword = function(keyword)
        {
            selectedKeyword = keyword;
            setDisplayMode(&#x27;keyword&#x27;);
            $(self).trigger(&#x27;changeDisplayed&#x27;, [self]);
            $(self).trigger(&#x27;change&#x27;, [self]);
            return self;
        };
        /**
         * Getter function for {{#crossLink &quot;dataManager/selectedKeyword:attribute&quot;}}{{/crossLink}}.
         * 
         * @method getSelectedKeyword
         * @return {String} The currently selected keyword
         */
        this.getSelectedKeyword = function() {
            return selectedKeyword;
        };
        /*
         * Method sets display mode to &#x27;marked&#x27; and restricts object to all currently marked.
         * Triggers {{#crossLink &quot;dataManager/changeDisplayed:event&quot;}}{{/crossLink}} and {{#crossLink &quot;dataManager/change:event&quot;}}{{/crossLink}}.
         * 
         * @method restrictToMarked
         * @chainable
         * return {Object} self
         */
        this.restrictToMarked = function()
        {
            setDisplayMode(&#x27;marked&#x27;);
            $(self).trigger(&#x27;changeDisplayed&#x27;, [self]);
            $(self).trigger(&#x27;change&#x27;, [self]);
            return self;
        };
        /**
         * Method to invert the marked objects. So all marked objects get unmarked and vice versa.
         * Triggers {{#crossLink &quot;dataManager/changeDisplayed:event&quot;}}{{/crossLink}} and {{#crossLink &quot;dataManager/change:event&quot;}}{{/crossLink}}.
         * 
         * @method reverseMarked
         * @chainable
         * return {Object} self
         */
        this.reverseMarked = function()
        {
            for(var i in self.objects) {
                if (self.isObjMarked(self.objects[i])) {
                    self.objects[i]._marked = false;
                } else {
                    self.objects[i]._marked = true;
                }

                self.allLoadedObjects[self.objects[i].data.pid]._marked = self.objects[i]._marked;
            }

            self.updateMarked();

            if ((self.getMarked().length == 0 ||
                   self.getMarked().length == self.objects.length ) &amp;&amp;
                     displayMode == &#x27;marked&#x27;) {
                setDisplayMode(&#x27;all&#x27;);
            }

            if (displayMode == &#x27;marked&#x27;) {
                currentObjects = self.getMarked();
            }

            $(self).trigger(&#x27;marked&#x27;, [self.getMarked()]);
            if (displayMode == &#x27;marked&#x27;) {
                $(self).trigger(&#x27;changeDisplayed&#x27;, [self]);    
            }
            $(self).trigger(&#x27;change&#x27;, [self]);
            return self;
        };
        /**
         * Getter for {{#crossLink &quot;dataManager/displayMode:attribute&quot;}}{{/crossLink}}
         *
         * @method getDisplayMode
         * @return {String} displayMode The currently used display mode.
         */
        this.getDisplayMode = function()
        {
            return displayMode;
        }
        /**
         * Method to select a collection to be displayed. Sets display mode to &#x27;collection&#x27;
         * Triggers {{#crossLink &quot;dataManager/changeDisplayed:event&quot;}}{{/crossLink}} and {{#crossLink &quot;dataManager/change:event&quot;}}{{/crossLink}}.
         * 
         * @method selectCollection
         * @chainable
         * @param {String} Collection-uid The title of the collection to display.
         * return {Object} self
         */
        this.selectCollection = function(which)
        {
            if (selectedCollection != which) {
                self.markObjects(false);
            }
            var selCollection = self.getCollection(which)
            
            var pic = $(&#x27;#pagination-info&#x27;);
            pic
                .attr(&quot;title&quot;,&quot;&quot;)
                .removeAttr(&quot;data-tooltip&quot;)
                .show()
                .find(&quot;.num&quot;).text(selCollection.title);
            pic.find(&quot;.suffix&quot;).text(&quot;&quot;);
                $(&#x27;#search-info&#x27;).show();
                $(&#x27;.search-previouspage, .search-nextpage&#x27;).hide();
            
            // Clear Search Field
            if($(&quot;#filter-canvas-filter-0&quot;).length) {
                $(&quot;#filter-canvas-filter-0&quot;).val(&quot;&quot;)
            }
            selectedCollection = which;
            setDisplayMode(&#x27;collection&#x27;);
            $(self).trigger(&#x27;changeDisplayed&#x27;, [self]);
            $(self).trigger(&#x27;change&#x27;, [self]);
            
            return self;
        };
        /**
         * Method to select the next object in the resultset.
         * 
         * @method selectNextObject
         * @return {Object} Object The resulting object delivered from {{#crossLink &quot;dataManager/selectObject:method&quot;}}{{/crossLink}}
         */
        this.selectNextObject = function(which)
        {
            return this.selectObject(++selectedObject);            
        };
        /**
         * Method select an object from the result set either by its index number or by the object&#x27;s PID number.
         * 
         * @method selectObject
         * @param {Number|Object} Identifier Either the object index or the object to select (i.e. a js object with pid attribute)
         * @return {Object}
         */
        this.selectObject = function(which)
        {
            if (typeof which == &#x27;number&#x27;) {
                if (which &lt; 0) {
                    which = currentObjects.length + which;
                }

                if (which &gt;= currentObjects.length) {
                    which = which - currentObjects.length;
                }

                selectedObject = which;
                return currentObjects[selectedObject];
            }

            if (typeof which == &#x27;object&#x27; &amp;&amp; typeof which[&#x27;pid&#x27;] != &#x27;undefined&#x27;) {
                for(var i in currentObjects) {
                    if (currentObjects[i].data.pid == which[&#x27;pid&#x27;]) {
                        selectedObject = i;
                        return currentObjects[selectedObject];
                    }
                }
            }
        };
        /**
         * Method to select the previous object in the resultset.
         * 
         * @method selectPreviousObject
         * @return {Object} Object The resulting object delivered from {{#crossLink &quot;dataManager/selectObject:method&quot;}}{{/crossLink}}
         */
        this.selectPreviousObject = function()
        {
            return this.selectObject(--selectedObject);
        };
        /**
         * Set a specific display mode (all|marked|collection|keyword).
         * If set to &#x27;collection&#x27; the value of {{#crossLink &quot;dataManager/selectedCollection:attribute&quot;}}{{/crossLink}} is used.
         * If set to &#x27;keyword&#x27; the value of {{#crossLink &quot;dataManager/selectedKeyword:attribute&quot;}}{{/crossLink}} is used.
         * Triggers {{#crossLink &quot;dataManager/displayModeChanged:event&quot;}}{{/crossLink}}
         * 
         * @method setDisplayMode
         * @chainable
         * @param {Enum} Enum The display mode to set (all|marked|collection|keyword)
         * return {Object} self
         */
        var setDisplayMode = function(mode, silent)
        {
            silent = (typeof silent == &#x27;undefined&#x27;) ? false : silent;
            displayMode = mode;

            if (mode == &#x27;all&#x27;) {
                selectedKeyword = null;
                currentObjects = self.objects;
                self.updateKeywords();
            }

            if (mode == &#x27;marked&#x27;) {
                selectedKeyword = null;
                currentObjects = self.getMarked();
            }

            if (mode == &#x27;collection&#x27;) {
                selectedKeyword = null;
                
                var col = self.getCollection(selectedCollection);
                if (col == null) { return setDisplayMode(&#x27;all&#x27;, silent); }

                currentObjects = col.objects;
                self.objects = col.objects;
                self.copyToAllLoadedObjects(self.objects, true);
                self.updateKeywords();
            }

            if (mode == &#x27;keyword&#x27;) {
                currentObjects = self.getObjectsForKeyword(selectedKeyword);
            }

            if (!silent) {
                $(self).trigger(&#x27;displayModeChanged&#x27;, [mode]);
            }
            
            return self;
        };
        /**
         * Method to remove all display restrictions and show all objects of the current result set.
         * Triggers {{#crossLink &quot;dataManager/changeDisplayed:event&quot;}}{{/crossLink}} and {{#crossLink &quot;dataManager/change:event&quot;}}{{/crossLink}}.
         * If the former display mode was &#x27;marked&#x27; it also triggers {{#crossLink &quot;dataManager/marked:event&quot;}}{{/crossLink}}.
         * 
         * @method showAll
         * @chainable
         * return {Object} self
         */
        this.showAll = function()
        {
            if (displayMode == &#x27;all&#x27;) {
                return self;
            }
            selectedKeyword = null;
            var formerMode = displayMode;
            
            setDisplayMode(&#x27;all&#x27;);

            if (formerMode == &#x27;marked&#x27;) {
                $(self).trigger(&#x27;marked&#x27;, [self.getMarked()]);
            }
            $(self).trigger(&#x27;changeDisplayed&#x27;, [self]);
            $(self).trigger(&#x27;change&#x27;, [self]);
            return self;
        };
        /**
         * Method updating the currently marked objects array (dataManager:objectsmarked).
         * Uses {{#crossLink &quot;dataManager/isObjMarked:method&quot;}}{{/crossLink}} to check whether an object was stared/marked.
         *
         * @method updateMarked
         * @chainable
         * @return {Object} self
         */
        this.updateMarked = function()
        {
            self.objectsmarked = [];
            for(var i in self.allLoadedObjects) {
                if (self.allLoadedObjects[i]._marked) {
                    self.objectsmarked.push(self.allLoadedObjects[i]);
                }
            }
            
            $(&quot;#markedimages&quot;).text(self.objectsmarked.length)
            return self;
        };
    }

    return dataManager;
});
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
